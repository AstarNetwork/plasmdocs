
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Optimistic Virtual Machine Â· Plasm Documentations</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="Plasma and beyond.">
        <meta name="generator" content="GitBook 3.2.3">
        
        <meta name="identifier" content="null" scheme="ISBN">
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../css/index.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="core-features.html" />
    
    
    <link rel="prev" href="generalized-plasma.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://github.com/stakedtechnologies/Plasm" target="_blank" class="custom-link">Plasm</a>
        </li>
    
        
        <li>
            <a href="http://crates.plasmnet.io" target="_blank" class="custom-link">Documentation(crates)</a>
        </li>
    
        
        <li>
            <a href="https://github.com/stakedtechnologies/plasmdocs/blob/master/wp/en.pdf" target="_blank" class="custom-link">PlasmProject Whitepaper(en)</a>
        </li>
    
        
        <li>
            <a href="https://github.com/stakedtechnologies/plasmdocs/blob/master/wp/jp.pdf" target="_blank" class="custom-link">PlasmProject Whitepaper(jp)</a>
        </li>
    
        
        <li>
            <a href="https://t.me/PlasmOfficial" target="_blank" class="custom-link">Telegram</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../">
            
                <a href="../">
            
                    
                    Welcome
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Ecosystem</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../ecosystem/introduction.html">
            
                <a href="../ecosystem/introduction.html">
            
                    
                    Polkadot
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../ecosystem/wiki-index.html">
            
                <a href="../ecosystem/wiki-index.html">
            
                    
                    Wiki Index
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../ecosystem/polkadot-and-plasm.html">
            
                <a href="../ecosystem/polkadot-and-plasm.html">
            
                    
                    Polkadot and Plasm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../ecosystem/substrate.html">
            
                <a href="../ecosystem/substrate.html">
            
                    
                    Substrate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../ecosystem/community.html">
            
                <a href="../ecosystem/community.html">
            
                    
                    Community
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Learn</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="./">
            
                <a href="./">
            
                    
                    Index
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="plasma-overview.html">
            
                <a href="plasma-overview.html">
            
                    
                    Plasma Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="generalized-plasma.html">
            
                <a href="generalized-plasma.html">
            
                    
                    Generalized Plasma
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.4" data-path="optimistic-virtual-machine.html">
            
                <a href="optimistic-virtual-machine.html">
            
                    
                    Optimistic Virtual Machine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="core-features.html">
            
                <a href="core-features.html">
            
                    
                    Core Features
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Build</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../build/untitled.html">
            
                <a href="../build/untitled.html">
            
                    
                    Running Node
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../build/plapps.html">
            
                <a href="../build/plapps.html">
            
                    
                    Plapps
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Maintain</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../maintain/untitled.html">
            
                <a href="../maintain/untitled.html">
            
                    
                    Untitled
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Workshop & Tutorial</li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../tutorial/untitled.html">
            
                <a href="../tutorial/untitled.html">
            
                    
                    Operator Trading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2" data-path="../tutorial/dapps-reward.html">
            
                <a href="../tutorial/dapps-reward.html">
            
                    
                    DApps Reward
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3" data-path="../tutorial/importing-ethereum-seed-key.html">
            
                <a href="../tutorial/importing-ethereum-seed-key.html">
            
                    
                    Importing Ethereum Seed Key
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.4" data-path="../tutorial/realtime-lockdrop.html">
            
                <a href="../tutorial/realtime-lockdrop.html">
            
                    
                    Realtime Lockdrop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.5" data-path="../tutorial/lockdrop.html">
            
                <a href="../tutorial/lockdrop.html">
            
                    
                    Lockdrop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.6" >
            
                <a target="_blank" href="https://github.com/staketechnologies/plasmdocs/blob/master/wp/en.pdf">
            
                    
                    Plasm Network White Paper
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Optimistic Virtual Machine</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="optimistic-virtual-machine">Optimistic Virtual Machine</h1>
<h4 id="to-do--modify-english">To Do : Modify English</h4>
<h3 id="what-is-optimistic-virtual-machine">What is Optimistic Virtual Machine?</h3>
<p>To put it simply, OVM (Optimistic Virtual Machine)  is the virtual machine designed to support all laye r2 protocols invented by the Ethereum Foundation Plasma Group. It is a possible unification of all layer2 scalabilities constructions. This means that <strong>Plasm Network will not only be for Plasma applications but also for Lightning Network applications or any other layer 2 protocols.</strong></p>
<p>Plasm Network is to be a platform that houses all layer 2 scaling solutions. Users can choose which solution to use and make their use case possible with minimum overheads.</p>
<h3 id="learn-more">Learn More</h3>
<p>OVM is a powerful concept to develop layer 2 applications. We can express complex dispute logics by a simple OVM language and that language contains <a href="https://plasma.group/optimistic-game-semantics.pdf" target="_blank">Optimistic Game Semantics</a> (OGS). </p>
<p>For example, we can express Plasma checkpoint and exit claims with 2 simple definitions (we call these &quot;property&quot;) by OGS. Plasm Network separates the OVM from the smart contract and prepares it as a module so that OVM can be used more simply and conveniently.</p>
<h3 id="ovm-in-plasm-network-">OVM in Plasm Network <a id="ovm-in-plasm-network"></a></h3>
<p>The OVM and its surrounding architecture are as shown in the figure below.</p>
<p><img src="https://user-images.githubusercontent.com/6259384/75546609-404d5880-5a6c-11ea-84d0-f063e0bc252c.png" alt="ovmodule"></p>
<p>Plasma applications (Plapps) can be created and run properly through the dedicated client application L1 adapter. Plapps are composed of OVM, Plasma and Contracts modules in Plasm Network. </p>
<p>In case of Ethereum Plasma applications, everything provided in these modules was managed by smart contracts. However, in this case, there is a problem that it is difficult to predict the gas cost when running a plasma application containing complicated logic. Also, building applications that combines multiple contracts can be confusing for developers. </p>
<p>For this reason, Plasma Network has considered a superficially concise and easy-to-understand configuration by separating the roles into three modules. The OVM Module implements a function called Universal Adjudication to cause a dispute when the user finds a mistake in the information on layer 1. The Plasma Module supports a common implementation of some of the essential smart contracts for Plasma. Only the implementations that require different logic for each application are managed by the Contracts Module.</p>
<p>These Plasm Network logics can be combined with the implementation provided by the Plasma L2 Implementation described above to build an application.</p>
<p>You can see the details below.</p>
<h2 id="smart-contract-">Smart Contract <a id="smart-contract"></a></h2>
<p>Smart contracts in Plasm Network&apos;s layer 2 applications require <strong>ERC20 Contracts</strong> and <strong>Payout Contracts</strong>. Each layer 2 application developer must implement their own smart contract.</p>
<h3 id="erc20-contract-">ERC20 Contract <a id="erc20-contract"></a></h3>
<p>ERC20 Contract is a contract that expresses tokens handled by layer 2 application. Refer to this specification for <a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank">ERC20</a>. We implement PLM&apos;s wrapped Contract as the default ERC20 Contract.</p>
<h4 id="wplm-contract-">wPLM contract <a id="wplm--contract"></a></h4>
<p>wPLM contract is a wrapped contract of PLM token. This is an ERC20 token issued by depositing the PLM token, the basic token of Plasm Network with the contract. In other words, it has the same value as PLM. This is like <a href="https://weth.io/jp/" target="_blank">wETH</a>.</p>
<h3 id="payout-contract-">Payout Contract <a id="payout-contract"></a></h3>
<p>Payout Contract is a contract that expresses the process when returning tokens from layer 2 to layer 1. layer 2 application developers must implement it because user can not withdraw without this contract. We implement <strong>Ownership payout contract</strong> as the default Payout Contract.</p>
<p>The above contract can be implemented without depends on the following ovm modules. Payout Contract must be able to call the <code>finalizeExit</code> method. This is enforced by the trait.</p>
<pre><code class="lang-text">function finalizeExit(
    address depositContractAddress,
    types.Property memory _exitProperty,
    uint256 _depositedRangeId,
    address _owner
)
</code></pre>
<h4 id="ownership-payout-contract-">Ownership payout contract <a id="ownership-payout-contract"></a></h4>
<p>Ownership payout contract is a contract that the token owner can withdraw. Specifically, When the Exit is determined to be true in the Challenge Game, the owner represented by that State Object (in this case, OwnershipPredicate) can withdraw the token. The Ownership Payout contract is expressed in the Ethereum contract like <a href="https://github.com/cryptoeconomicslab/ovm-contracts/blob/master/contracts/Predicate/plasma/OwnershipPayout.sol" target="_blank">this</a>.</p>
<h2 id="modules-">Modules <a id="modules"></a></h2>
<p>Operations related to OVM are implemented by the Substrate runtime module. This is so that users do not have to deploy complex smart contracts. This is intended to make gas costs of deployment cheap and easy to estimate. In addition, this makes developers of layer 2 applications can consider and implement only the essentially required &quot;ERC20 contract&quot; and &quot;Payment contract&quot; and properties that indicate the rules of state transition.</p>
<p>Then, it is necessary to consider special storage that can handle the layer 2 application with the Substrate Runtime Module. It treats one application as one AccountId in the same way as a smart contract.</p>
<p>Specifically, it can be divided into OVM Modules, which perform general OVM processing, and Plasma modules, which are responsible for plasma-specific processing. See the architecture diagram for the dependencies of each module and contract.</p>
<h2 id="ovm-module-">OVM Module <a id="ovm-module"></a></h2>
<p>OVM Module describes the processing commonly performed in OVM. Specifically, the execution logic of Predicate is included in this module. In addition, the smart contract is executed by using the truth of Predicate as a trigger. This module is a modularized version of <a href="https://github.com/cryptoeconomicslab/ovm-contracts/blob/master/contracts/UniversalAdjudicationContract.sol" target="_blank">Universal Adjudication contract</a> in the Ethereum Smart contract.</p>
<h3 id="types-">Types <a id="types"></a></h3>
<p>Defines the type used by OVM Module.</p>
<pre><code class="lang-text">pub struct Predicate(Vec&lt;u8&gt;);

pub struct Property&lt;AccountId&gt; {
    predicate_address: AccountId,
  // Every input are bytes. Each Atomic Predicate decode inputs to the specific type.
    inputs: Vec&lt;u8&gt;,
}

pub enum Decision {
    Undecided,
    True,
    False
}

pub struct ChallengeGame&lt;AccountId, BlockNumber&gt; {
    property: Property&lt;AccountId&gt;,
    challenges: Vec&lt;u8&gt;,
    decision: Decision,
    created_block: BlockNumber,
}

pub struct Range&lt;Balance&gt; {
    start: Balance,
    end: Balance,
}
</code></pre>
<h3 id="universal-adjudication-">Universal Adjudication <a id="universal-adjudication"></a></h3>
<h4 id="constants-">Constants <a id="contants"></a></h4>
<pre><code class="lang-text">/// During the dispute period defined here, the user can challenge. If nothing is found, the state is determined after the dispute period.
type DISPUTE_PERIOD: T::Moment = 7;
</code></pre>
<h4 id="storage-">Storage <a id="storage"></a></h4>
<pre><code class="lang-text">decl_storage! {
    Predicate get(fn predicate): map T::AccountId =&gt; T::Predicate;
    DisputePeriod get(fn dispute_period): T::Moment;
    InstantiatedGames get(fn instantiated_games): map T::Hash =&gt; T::ChallengeGame;
}
</code></pre>
<h4 id="modules-">Modules <a id="modules"></a></h4>
<pre><code class="lang-text">decl_storage! {
    fn deploy(predicate: T::Predicate);
    fn claim_property(claim: T::Property);
    fn decide_claim_to_true(game_id: T::Hash);
    fn decide_claim_to_false(game_id: T::Hash, challenging_game_id: T::Hash);
    fn remove_challenge(game_id: T::Hash, challenging_game_id: T::Hash);
    fn set_predicate_decision(game_id: T::Hash, decision: bool);
    /**
   * @dev challenge a game specified by gameId with a challengingGame specified by _challengingGameId
   * @param _gameId challenged game id
   * @param _challengeInputs array of input to verify child of game tree
   * @param _challengingGameId child of game tree
   */
    fn challenge(game_id: T::Hash, challenge_inputs: Vec&lt;u8&gt;, challenging_game_id);

    /// callable
    fn is_decided(property: T::Property);
    fn get_game(claim_id: T::Hash);
    fn get_property_id(property: T::Property);
}
</code></pre>
<h4 id="events-">Events <a id="events"></a></h4>
<pre><code class="lang-text">// (predicate_address: AccountId);
DeployPredicate(AccountId);
// (gameId: Hash, decision: bool)
AtomicPropositionDecided(Hash, bool);
// (game_id: Hash, property: Property, createdBlock: BlockNumber)
NewPropertyClaimed(Hash, Property, BlockNumber);
// (game_id: Hash, challengeGameId: Hash)
ClaimChallenged(Hash, Hash);
// (game_id: Hash, decision: bool)
ClaimDecided(Hash, bool);
// (game_id: Hash, challengeGameId: Hash)
ChallengeRemoved(Hash, Hash);
</code></pre>
<h2 id="plasma-module-">Plasma Module <a id="plasma-module"></a></h2>
<p>Plasma Module is a module that is responsible for processing specific to Plasma. It calls the OVM Module and the specified smart contract function. The Plasma Module has one &quot;Commitment&quot; and &quot;Deposit&quot; address per application. These are each defined by <code>decl_child_storage</code>. <code>decl_child_storage!</code> is a macro that implements DB in SubTrie. This sets AccountId as the key value. This is like a contract address. Specifically, implements with reference to <a href="https://github.com/paritytech/substrate/blob/master/frame/contracts/src/account_db.rs" target="_blank">AccountDb</a> of contract module.</p>
<p>This is modularized <a href="https://github.com/cryptoeconomicslab/ovm-contracts/blob/master/contracts/CommitmentContract.sol" target="_blank">Commitment</a>, <a href="https://github.com/cryptoeconomicslab/ovm-contracts/blob/master/contracts/DepositContract.sol" target="_blank">Deposit</a> and <a href="https://github.com/cryptoeconomicslab/ovm-contracts/blob/master/contracts/Predicate/CompiledPredicate.sol" target="_blank">CompiledPredicate</a> contracts in the Ethereum.</p>
<h3 id="types-">Types <a id="types"></a></h3>
<p>Defines the type used by Plasma Module.</p>
<pre><code class="lang-text">pub struct StateUpdate&lt;AccountId, Balance, BlockNumber&gt; {
    deposit_contract_address: AccountId,
    ragne: Range&lt;Balance&gt;,
    block_number: BlockNumber,
    state_object: Property&lt;AccountId&gt;,
}

pub struct Checkpoint&lt;AccountId, Balance&gt; {
    subsrange: Range&lt;Balance&gt;,
    state_update: Property&lt;AccountId&gt;,
}

pub struct Exit&lt;AccountId, Range, BlockNumber, Property, Balance, Index&gt; {
    state_update: StateUpdate&lt;AccountId, Range, BlockNumber, Property&gt;,
    inclusion_proof: InclusionProof&lt;AccountId, Balance, Index&gt;
}

pub struct InclusionProof&lt;AccountId, Balance, Index&gt; {
    address_inclusion_proof: AddressInclusionProof&lt;AccountId, Index&gt;
    interval_inclusion_proof: IntervalInclusionProof&lt;Balance, Index&gt;,
}

pub struct IntervalInclusionProof&lt;Balance, Index&gt; {
    leaf_index: Index,
    leaf_position: Index,
    sibilings: Vec&lt;IntervalTreeNode&lt;Balance&gt;&gt;
}

pub struct AddressInclusionProof&lt;AccountId, Index&gt; {
    leaf_index: AccountId,
    leaf_position: Index,
    siblings: Vec&lt;AddressTreeNode&lt;AccountId&gt;&gt;,
}

pub struct IntervalTreeNode&lt;Balance&gt; {
    data: Vec&lt;u8&gt;,
    start: Balance,
}

pub struct AddressTreeNode&lt;AccountId&gt; {
    data: Vec&lt;u8&gt;,
    token_address: AccountId,
}
</code></pre>
<h4 id="modules-">modules <a id="modules"></a></h4>
<pre><code class="lang-text">/// Commitment constructor + Deposit constructor
fn deploy(
    aggregator_address: T::AccountId,
    erc20: T::AccountId,
    state_update_predicate: T::AccountId);
</code></pre>
<h3 id="commitment-">Commitment <a id="commitment"></a></h3>
<p>Commitment is something to save the Merkle Root owned by the Plasma child chain. Child storage of Commitment is generated for each layer 2 application. This can be used like accessing smart contracts.</p>
<h4 id="storage-">Storage <a id="storage"></a></h4>
<pre><code class="lang-text">// Commitment storage: Plapps address =&gt; Commitment Child Storage.
Commitment get(fn commitment): T::AccountId =&gt; Commitment;
</code></pre>
<pre><code class="lang-text">decl_child_storage! {
    Commitment {
        // Single operator address: OperatorId
        OperatorAddress get(fn operator_address): T::AccountId;
        // Current block number of commitment chain: BlockNumber
        CurrentBlock get(fn current_block): T::BlockNumber;
        // History of Merkle Root
        Blocks get(fn blocks): map u128 =&gt; T::Hash
    }
}
</code></pre>
<h3 id="modules-">Modules <a id="modules"></a></h3>
<pre><code class="lang-text">decl_modules! {
    fn submitRoot(blk_number: u64, root: T::Hash); 

  /**
   * verifyInclusion method verifies inclusion of message in Double Layer Tree.
   * The message has range and token address and these also must be verified.
   * Please see https://docs.plasma.group/projects/spec/en/latest/src/01-core/double-layer-tree.html for further details.
   * @param _leaf a message to verify its inclusion
   * @param _tokenAddress token address of the message
   * @param _range range of the message
   * @param _inclusionProof The proof data to verify inclusion
   * @param _blkNumber block number where the Merkle root is stored
   */
    fn verifyInclusion(leaf: T::Hash, address, T::AccountId, range: T::Range, inclusionProof: InclusionProof, blk_number);
}
</code></pre>
<h3 id="events-">Events <a id="events"></a></h3>
<pre><code class="lang-text">// Event definitions (AccountID: PlappsAddress, BlockNumber, Hash: root)
BlockSubmitted(AccountId, BlockNumber, Hash);
</code></pre>
<h3 id="deposit-">Deposit <a id="deposit"></a></h3>
<p>Deposit is something to deposit ERC20 tokens from layer 1 to layer 2. Child storage of Deposit is generated for each layer 2 application. This can be used like accessing smart contracts.</p>
<h4 id="storage-">Storage <a id="storage"></a></h4>
<pre><code class="lang-text">// Deposit storage: Plapps address =&gt; Deposit Child Storage.
Deposit get(fn deposit): T::AccountId =&gt; Deposit;

decl_child_storage! {
    Commitment {
    ERC20 get(fn erc20): T::AccountId;
    CommitmentContract get(fn commitment_contract): T::AccountId;
    UniversalAdjudicatinonContract get(fn universalAdjudicationContract);
    StateUpdatePredicate get(fn state_update_predicate): T::AccountId;

    TotalDeposited get(fn total_deposited): T::Balance;
    DepositedRanges get(fn deposited_ranges): map T::Balance =&gt; T::Range;
    Checkpoints get(fn checkpoints): map T::Hash =&gt; T::Checkpoint;
    }
}
</code></pre>
<h4 id="modules-">Modules <a id="modules"></a></h4>
<pre><code class="lang-text">decl_modules! {
    fn deposit(amount: T::Balance, initial_state: T::Property);
    fn extend_deposited_ranges(amount: T::Balance);
    fn remove_deposited_range(range: T::Range, depositedRangeId: T::Balance);
    fn finalize_check_point(checkpoint_property: T::Property);
    fn finalizeExit(exit_property: T::Property, deposited_range_id: T::Balance);

    /// callable
    fn is_subrange(subrange: T::Range, surroundingRange T::Range);
}
</code></pre>
<h4 id="events-">Events <a id="events"></a></h4>
<pre><code class="lang-text">// (checkpointId: Hash, checkpoint: Checkpoint);
CheckpointFinalized(Hash, Checkpoint);
// (exit_id: Hash)
ExitFinalized(Hash);
// (new_range: Range)
DepositedRangeExtended(Range);
// (removed_range: Range)
DepositedRangeRemoved(Range);
</code></pre>
<h3 id="compiled-predicate-">Compiled Predicate <a id="compiled-predicate"></a></h3>
<p>The role of <code>CompiledPredicate</code> is optimizing claim size by compiling complex proposition to one simple predicate. The Plasma Module has method for running layer 2 applications via Predicate. <code>PayoutContract</code> withdrawal processing that exists for each layer 2 application can only be called via Compiled Predicate. This allows for transactions layer 2 as secure as layer 1.</p>
<h4 id="storage-">Storage <a id="storage"></a></h4>
<pre><code class="lang-text">/// predicate address =&gt; payout address
PayoutContractAddress get(fn payout_contract_address): map T::AccountId =&gt; T::AccountId;
</code></pre>
<h4 id="modules-">Modules <a id="modules"></a></h4>
<pre><code class="lang-text">fn decide_true(predicate_address: T::AccountId, inputs: Vec&lt;u8&gt;, witness: Vec&lt;u8&gt;);

/// callable
fn is_valid_challenge(predicate_address: T::AccountId, inputs: Vec&lt;u8&gt;, challenge_inputs: Vec&lt;u8&gt;, challenge: T::Property);
fn decide(predicate_addres: T::AccountId, inputs: Vec&lt;u8&gt;, witness: Vec&lt;u8&gt;);
</code></pre>
<h2 id="for-substrate--polkadot--ink-">For Substrate &amp; Polkadot &amp; ink! <a id="for-substrate--polkadot--ink"></a></h2>
<p>The above OVM specification can be handled by all Substrate Chains in common. Also, Polkadot and the following specification are independent concepts with no direct relationship; Handling layer 2 solutions by Polkadot can be achieved by connecting the Polkadot Network with a Polkadot Parachain that implements the following specification.</p>
<p>The above specification recommends the ink! contract as a smart contract. This is because Substrate&apos;s default smart contract specification is ink! Therefore, if you want to use it in EVM, etc., you can run different smart contract modules in the same way by preparing an implementation with the same specification.</p>
<p>The processes for OVM and Plasma can be handled as a Runtime module (pallet) of the Substrate, respectively. Properly importing each module implemented according to the specification will allow an arbitrary chain to work with these specifications.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="generalized-plasma.html" class="navigation navigation-prev " aria-label="Previous page: Generalized Plasma">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="core-features.html" class="navigation navigation-next " aria-label="Next page: Core Features">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"Plasma and beyond.","title":"Optimistic Virtual Machine","level":"3.4","depth":1,"next":{"title":"Core Features","level":"3.5","depth":1,"path":"learn/core-features.md","ref":"learn/core-features.md","articles":[]},"previous":{"title":"Generalized Plasma","level":"3.3","depth":1,"path":"learn/generalized-plasma.md","ref":"learn/generalized-plasma.md","articles":[]},"dir":"ltr"},"config":{"plugins":["katex"],"styles":{"website":"css/index.css"},"pluginsConfig":{"fontSettings":{"theme":"sepia","family":"serif","size":1},"katex":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageBreaksBefore":"/","headerTemplate":null,"paperSize":"a4","margin":{"right":62,"left":62,"top":36,"bottom":36},"fontSize":12,"fontFamily":"Arial","footerTemplate":null,"chapterMark":"pagebreak","pageNumbers":false},"structure":{"langs":"LANGS.md","readme":"Introduction.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"isbn":"null","variables":{},"title":"Plasm Documentations","links":{"sidebar":{"Plasm":"https://github.com/stakedtechnologies/Plasm","Documentation(crates)":"http://crates.plasmnet.io","PlasmProject Whitepaper(en)":"https://github.com/stakedtechnologies/plasmdocs/blob/master/wp/en.pdf","PlasmProject Whitepaper(jp)":"https://github.com/stakedtechnologies/plasmdocs/blob/master/wp/jp.pdf","Telegram":"https://t.me/PlasmOfficial"},"sharing":{"google":true,"facebook":true,"twitter":true,"weibo":true,"all":true}},"gitbook":"*","description":null,"extension":null},"file":{"path":"learn/optimistic-virtual-machine.md","mtime":"2020-05-30T09:55:38.888Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-05-30T09:56:41.377Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

